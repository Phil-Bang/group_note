{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Data 길들이기 End To End"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![realWorldData](./pics/realData.jpg)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 데이터를 받는 순간 어떻게 나눌지, 요약할 지를 생각하자!"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 빅데이터를 그대로 파이썬으로 불러 오고자할 때의 단점\n",
    "1. 메모리에 한꺼번에 올리기가 어렵다.\n",
    "1. 전체 파악이 어려워 Domain 지식을 적용 하기 어렵다.\n",
    "1. 거대한 프로젝트를 하기전 SW 프로토 타이핑에 용이한 Python 언어가 무용지물이 된다."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 데이터를 최대한 나눌 수 있다면\n",
    "1. 샘플링 및 데이터 감잡기가 용이하다.\n",
    "1. 적은 비용(시간, 컴퓨팅 자원, 사람)으로 대용량 분석 절차를 설계/시뮬레이션 할 수 있다.(Scalability)\n",
    "1. 대대적인 분석 중 예상치 못한 결과가 나온다면 분석 절차의 오류를 빨리 찾을 수 있다."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<div class = \"alert alert-info\">\n",
    "    \n",
    "**NOTE:**\n",
    "\n",
    "파이선은 다양한 라이브러리를 활용해서 실현 가능한 아이디어인지 빠르게 검증해 보는 Tool이다.\n",
    "파이선의 이러한 장점을 충분히 활용하기 위해서는 데이터를 작게 정재하고 어떻게 샘플링할 것인지에 대한 고민이 필요하다.\n",
    "\n",
    "</div>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "3.7.1\n",
      "0.23.4\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "from platform import python_version\n",
    "print(python_version())\n",
    "print(pd.__version__)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 3GB CSV의 형태를 어떻게 빨리 파악할 수 있을까?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%ls\n",
    "filename = None # 폴더 구분은 '/'를 사용"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 실행하시지 않기를 원하지만, 한번 해 보시는 것도 좋은 경험이 됨.\n",
    "df = pd.read_csv(filename)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df = pd.read_csv(filename, None)\n",
    "df"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 절대로 큰 파일을 한번에 읽으려 하지 말자"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "1. read_csv에 유용한 옵션들\n",
    "    * nrows : 첫번째 부터 몇개의 Row만 가져오고자 할 때\n",
    "    * header : header(=colum 이름)을 파일로 부터 어떻게 힌트를 얻고자 하는 지.\n",
    "    * encoding : 문자열 인코딩 설정(utf-8, euc-kr, cp949, ms949 등..)\n",
    "    * delimiter : csv의 구분자를 설정\n",
    "\n",
    "\n",
    "2. 한줄씩 텍스트 그대로를 보고싶다면?\n",
    "    * generator를 활용"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 이터레이터와 제네레이터"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![iterGen](./pics/iterGenRelation.png)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def method():\n",
    "    print(\"Start method()\")\n",
    "    val = []\n",
    "    for x in range(0,5):\n",
    "        val.append( x**2 )\n",
    "    return val"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "out = method()\n",
    "for i in range(0,5):\n",
    "    print(out[i])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def generator():\n",
    "    print(\"Start generator()\")\n",
    "    for x in range(0,5):\n",
    "        yield x**2\n",
    "        \n",
    "gen = generator()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for i in range(0,5):\n",
    "    print(next(gen))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 3GB CSV 파일을 일부만 읽어 보려면?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#TODO 한줄씩만 읽는 Generator를 만들어 보기\n",
    "import csv\n",
    "def genReadingCsv(fileName):\n",
    "    with open(filename, 'r') as csvFile :\n",
    "        datareader = csv.reader(csvFile)\n",
    "        for row in datareader:\n",
    "            None\n",
    "            \n",
    "gen = genReadingCsv(filename)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#TODO Generator를 사용하여 출력해 2줄만 출력해 보기\n",
    "for i in None:\n",
    "    print(None)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "#TODO 한줄 씩 불러 보기\n",
    "print(next(gen))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#TODO Delimiter를 바꿔 다시 DataFrame으로 읽기\n",
    "df = pd.read_csv(filename, None)\n",
    "df"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "우리가 가지고 있는 사전 정보가 아래와 같다고 하자\n",
    "\n",
    "1. 첫번째 컬럼 : ID\n",
    "2. 두번째 컬럼 : ID가 속한 상위 카테고리\n",
    "3. 세번째 컬럼 : 목표값\n",
    "4. 여섯 번째 컬럼~끝 : 각 ID가 시간 순서에 따라 가지는 값 "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 읽은 테이블을 Tidy Data로"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "ID | Time stamp | Value | Category\n",
    "--|--|--|--\n",
    "Interger | Integer | Float | Character\n",
    "\n",
    "어떻게 할 지 직접 손으로 적어보자"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Pandas Reshaping and Pivot Tables"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![pandasPivotBasic](./pics/pandasPivot.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![pandasStack](./pics/pandasStack.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![pandasUnStack](./pics/pandasUnstack.png)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# stack을 이용하여 tidy data로\n",
    "df.iloc[None].None\n",
    "# 이렇게만 하면 되는 걸까?"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![pandasMelt](./pics/pandasMelt.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "ID | Time stamp | Value | Category\n",
    "--|--|--|--\n",
    "Interger | Integer | Float | Character"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#TODO Melt로 아래의 형태가 출력되도록 하기\n",
    "#Hint index 재정렬은 reset_index() 함수를 사용함\n",
    "dfMelted = df.melt(id_vars=None, value_vars = None).sort_values(None)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>0</th>\n",
       "      <th>1</th>\n",
       "      <th>2</th>\n",
       "      <th>variable</th>\n",
       "      <th>value</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>1</td>\n",
       "      <td>A</td>\n",
       "      <td>5.017305e+09</td>\n",
       "      <td>5</td>\n",
       "      <td>113.782442</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>1</td>\n",
       "      <td>A</td>\n",
       "      <td>5.017305e+09</td>\n",
       "      <td>6</td>\n",
       "      <td>126.889214</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>1</td>\n",
       "      <td>A</td>\n",
       "      <td>5.017305e+09</td>\n",
       "      <td>7</td>\n",
       "      <td>133.954805</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>1</td>\n",
       "      <td>A</td>\n",
       "      <td>5.017305e+09</td>\n",
       "      <td>8</td>\n",
       "      <td>138.332467</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>1</td>\n",
       "      <td>A</td>\n",
       "      <td>5.017305e+09</td>\n",
       "      <td>9</td>\n",
       "      <td>141.945990</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>5</th>\n",
       "      <td>1</td>\n",
       "      <td>A</td>\n",
       "      <td>5.017305e+09</td>\n",
       "      <td>10</td>\n",
       "      <td>144.451147</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>6</th>\n",
       "      <td>1</td>\n",
       "      <td>A</td>\n",
       "      <td>5.017305e+09</td>\n",
       "      <td>11</td>\n",
       "      <td>145.096543</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>7</th>\n",
       "      <td>1</td>\n",
       "      <td>A</td>\n",
       "      <td>5.017305e+09</td>\n",
       "      <td>12</td>\n",
       "      <td>142.621448</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>8</th>\n",
       "      <td>1</td>\n",
       "      <td>A</td>\n",
       "      <td>5.017305e+09</td>\n",
       "      <td>13</td>\n",
       "      <td>138.139086</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>9</th>\n",
       "      <td>1</td>\n",
       "      <td>A</td>\n",
       "      <td>5.017305e+09</td>\n",
       "      <td>14</td>\n",
       "      <td>135.355239</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "   0  1             2  variable       value\n",
       "0  1  A  5.017305e+09         5  113.782442\n",
       "1  1  A  5.017305e+09         6  126.889214\n",
       "2  1  A  5.017305e+09         7  133.954805\n",
       "3  1  A  5.017305e+09         8  138.332467\n",
       "4  1  A  5.017305e+09         9  141.945990\n",
       "5  1  A  5.017305e+09        10  144.451147\n",
       "6  1  A  5.017305e+09        11  145.096543\n",
       "7  1  A  5.017305e+09        12  142.621448\n",
       "8  1  A  5.017305e+09        13  138.139086\n",
       "9  1  A  5.017305e+09        14  135.355239"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "dfMelted.head(10)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "평균등의 Aggreation 함수 계산 후 Reshape 하고 싶을 때 참고\n",
    "![pandasPivot](./pics/pivot-table-datasheet.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 시각화 - Matplotlib"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![matplotTerms](./pics/matplotlib.png)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# %matplotlib notebook\n",
    "%matplotlib inline\n",
    "# 항상 그리기 시작하는 곳에 설정 필요\n",
    "import numpy as np\n",
    "import matplotlib.pylab as plt"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "x = np.linspace(-2, 2, 11)\n",
    "f = lambda x: x ** 2\n",
    "fx = f(x)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(x)\n",
    "print(fx)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plt.plot(x, fx, '-o')\n",
    "plt.grid()\n",
    "plt.xlabel('x')\n",
    "plt.ylabel('y')\n",
    "plt.title('1d graph')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "xx = np.linspace(-2,2, 11)\n",
    "yy = np.linspace(-2,2, 11)\n",
    "\n",
    "print(xx)\n",
    "print(yy)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "xx,yy = np.meshgrid(xx,yy)\n",
    "print(xx)\n",
    "print(yy)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "f = lambda xx,yy : (xx-1)**2 + (yy-1)**2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "z = f(xx,yy)\n",
    "print(z)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "\n",
    "fig3d, ax2 = plt.subplots()\n",
    "ax2 = plt.axes(projection='3d', elev=50, azim=-50)\n",
    "ax2.plot_surface(xx, yy, z, cmap=plt.cm.jet)\n",
    "\n",
    "ax2.set_xlabel('$x$')\n",
    "ax2.set_ylabel('$y$')\n",
    "ax2.set_zlabel('$z$')\n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 나란히 나타내기\n",
    "fig = plt.figure(figsize=(15,5))\n",
    "# Fisrt subplot\n",
    "ax = fig.add_subplot(1,2,1)\n",
    "\n",
    "ax.plot(x, fx, '-o')\n",
    "ax.grid(True)\n",
    "ax.set_ylabel('Damped oscillation')\n",
    "\n",
    "# Second subplot\n",
    "ax = fig.add_subplot(1, 2, 2, projection='3d',elev=50, azim=-50)\n",
    "ax.plot_surface(xx, yy, z, cmap=plt.cm.jet)\n",
    "ax.set_xlabel('$x$')\n",
    "ax.set_ylabel('$y$')\n",
    "ax.set_zlabel('$z$')\n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Contour를 그릴 수 있음.\n",
    "x = np.linspace(-2,2, 11)\n",
    "y = np.linspace(-2,2, 11)\n",
    "x,y = np.meshgrid(x,y)\n",
    "\n",
    "ax = plt.axes()\n",
    "ax.contour(x, y, z, levels=np.linspace(0, 20, 20), cmap=plt.cm.jet)\n",
    "ax.grid()\n",
    "ax.axis('equal')\n",
    "ax.set_xlabel('$x$')\n",
    "ax.set_ylabel('$y$')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "grad_f_x = lambda x, y: 2 * (x-1)\n",
    "grad_f_y = lambda x, y: 2 * (y-1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "dz_dx = grad_f_x(x,y)\n",
    "dz_dy = grad_f_y(x,y)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Vector를 그릴 수 있음.\n",
    "ax = plt.axes()\n",
    "ax.quiver(x, y, -dz_dx, -dz_dy)\n",
    "ax.grid()\n",
    "ax.axis('equal')\n",
    "ax.set_xlabel('$x$')\n",
    "ax.set_ylabel('$y$')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#둘을 합쳐서 하나로 그릴 수 있음.\n",
    "ax = plt.axes()\n",
    "ax.contour(x, y, z, levels=np.linspace(0, 10, 20), cmap=plt.cm.jet)\n",
    "ax.quiver(x, y, -dz_dx, -dz_dy)\n",
    "ax.grid()\n",
    "ax.axis('equal')\n",
    "ax.set_xlabel('$x$')\n",
    "ax.set_ylabel('$y$')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 우리가 가진 데이터를 그려보자"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# TODO ID 1번 만 Value 그려보기\n",
    "var = None\n",
    "val = None\n",
    "plt.figure(figsize=(10,5))\n",
    "plt.plot(None, '-o')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# TODO ID 1,3,5 Value 할당하기\n",
    "A_1 = None\n",
    "A_3 = None\n",
    "A_5 = None"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#TODO Box Plot\n",
    "ax = plt.axes()\n",
    "ax.boxplot(None)\n",
    "ax.set_xticklabels(['A_1','A_3','A_5'])\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#TIP table describe으로 테이블 전체 한눈에 정리하기\n",
    "dfMelted.describe(include = 'all')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "#TODO ID별 평균 분산 Target 테이블 정리 - pivot table 함수 이용\n",
    "pd.pivot_table(dfMelted, None)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#TIp 컬럼이름을 그냥 두면 에러가 나네???\n",
    "dfMelted.columns = map(str,dfMelted.columns)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#TODO ID별 평균 분산 Target 테이블 정리 - 컬럼이름 변경 후 다시\n",
    "dfMeltedPivoted = pd.pivot_table(dfMelted, index = '0', values = ['variable','value','2'], aggfunc = [np.mean, np.var])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "x = dfMeltedPivoted.iloc[:,4] # variance\n",
    "y = dfMeltedPivoted.iloc[:,1] # mean\n",
    "z = dfMeltedPivoted.iloc[:,0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#TODO 평균, 분산 vs Target 3D Scatter Plot\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "\n",
    "axN = plt.subplots()\n",
    "None\n",
    "\n",
    "axN.set_xlabel('$mean$')\n",
    "axN.set_ylabel('$variance$')\n",
    "axN.set_zlabel('$targe$')\n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Sessionization"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 왜 필요한가?\n",
    "\n",
    "1. 연속된 데이터에서 특정 이벤트로 구간을 나눠야할 때\n",
    "    * 차에서 풍량버튼을 2에서 10으로 가기 위해 7번 눌렀다고 이 사용자의 풍량 조절 요구량을 7번으로 카운트할 수 있을까?\n",
    "    * 자곡동에 살고 있는 강사의 GPS가 자곡동에 계속 머문다고 해서 자곡동에 자주 방문한다고 할 수 있을까?   \n",
    "    \n",
    "    \n",
    "2. 특정 조건에 맞는 구간이 전체 데이터에서 몇 개 있는 지 알고 싶을 때\n",
    "    * 분석 조건에 맞는 구간을 찾았는데 그 결과가 전체 데이터의 0.01%도 안될 때, 이 분석은 구지 어렵게 할 필요가..."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "filename = 'D:/workspace/BigdataEduDocs/2_Python_End2End/ref/file/bigSample.csv'\n",
    "df = pd.read_csv(filename, nrows = 5, header = None, encoding = 'utf-8', delimiter = '\\x01')\n",
    "dfMelted = df.melt(id_vars=[0,1,2], value_vars = df.columns[5:]).sort_values([0,'variable']).reset_index(drop=True)\n",
    "dfMelted.columns = map(str,dfMelted.columns)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "dfMelted.head(5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# TODO 100에서 150 사이 조건 정하기\n",
    "cond1 = None\n",
    "cond2 = None\n",
    "dfMelted['cond'] = cond1 & cond2\n",
    "# cond1,cond2를 한줄에 쓰면 되지 않는가???"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# TODO 변하는 구간 찾아 session 채번하기\n",
    "dfMelted['condShift'] = None # shift 함수를 써서 한칸씩 밀린 Column 만들기\n",
    "dfMelted['condTransition'] = None # lambda row : np.invert(np.array_equal(row['cond'],row['condShift'])), axis = 1 사용 Transition 판단\n",
    "dfMelted['session'] = None # Transition을 cumulative sum -> 이렇게함 해도 될까? 데이터 확인 하기."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 데코레이터\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 왜 필요한가?\n",
    "\n",
    "1. 테이블을 다루는 Pandas 함수들은 Column Wise, Row Wise 연산 관련 기본 함수들을 제공한다.\n",
    "    * Column Wise : df['new'] = df[df['value'] > 0]\n",
    "    * Row Wise : apply function\n",
    "    \n",
    "    \n",
    "2. 만약 Apply function에 이전 Row 계산시 발생한 컬럼의 값을 이번 Row 계산에 사용하고 싶다면? \n",
    "    * cumsum 같이 이미 준비된 함수도 있지만, 더하기 외의 기능은 직접 구현 필요"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "dfDecoEx = pd.DataFrame({'a':[0,1,2], 'b':[0,10,20]})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def apply_func_decorator(func):\n",
    "    prev_row = {}\n",
    "    def wrapper(curr_row, **kwargs):\n",
    "        xx = func(curr_row, prev_row)\n",
    "        prev_row.update(curr_row)\n",
    "        prev_row['xx'] = xx\n",
    "        return xx\n",
    "    return wrapper\n",
    "\n",
    "@apply_func_decorator\n",
    "def prevRowFunc(curr_row, prev_row):\n",
    "    xx = curr_row['a'] + curr_row['b'] - prev_row.get('xx', 0)\n",
    "    return xx\n",
    "\n",
    "ans = dfDecoEx.apply(prevRowFunc, axis=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "dfAns = ans.apply(pd.Series)\n",
    "result = pd.concat([dfDecoEx, dfAns], axis=1, sort=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "result"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 유용한 Python Tools"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 프로파일링"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* % : Line magic 실행\n",
    "* %% : Cell magic 실행\n",
    "* 참조 : https://ipython-books.github.io/chapter-4-profiling-and-optimization/"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%load_ext line_profiler\n",
    "%load_ext memory_profiler"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 함수별 프로파일링 %prun\n",
    "import random\n",
    "\n",
    "def do_stuff(numbers):\n",
    "    s = sum(numbers)\n",
    "    l = [numbers[i]/43 for i in range(len(numbers))]\n",
    "    m = ['hello'+str(numbers[i]) for i in range(len(numbers))]\n",
    "\n",
    "%prun numbers = [random.randint(1,100) for i in range(1000)]\n",
    "# total : subfunction을 실행하는 데 필요한 시간을 제외하고 실행하는 데 걸린 시간\n",
    "# cumulative : subfunction까지 실행하는데 필요한 시간을 포함하여 실행하는 데 걸린 시간"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 라인 별 프로파일링 %lprun\n",
    "def step(*shape):\n",
    "    # Create a random n-vector with +1 or -1 values.\n",
    "    return 2 * (np.random.random_sample(shape)<.5) - 1\n",
    "\n",
    "def simulate(iterations, n=10000):\n",
    "    s = step(iterations, n)\n",
    "    x = np.cumsum(s, axis=0)\n",
    "    bins = np.arange(-30, 30, 1)\n",
    "    y = np.vstack([np.histogram(x[i,:], bins)[0]\n",
    "                   for i in range(iterations)])\n",
    "    return y"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%lprun -f simulate simulate(50)\n",
    "# Timer unit * Time을 통해 각 라인별 소요 시간 비율을 알 수 있음."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%writefile memscript.py\n",
    "import csv\n",
    "def genReadingCsv(fileName): # 앞에서 만들었던 \n",
    "    with open(filename, 'r') as csvFile :\n",
    "        datareader = csv.reader(csvFile)\n",
    "        for row in datareader:\n",
    "            yield row"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 메모리 프로파일링 %mprun - 메모리 프로파일은 파일로 함수를 만들어 두었을 때만 수행 가능\n",
    "from memscript import genReadingCsv\n",
    "filename = 'D:/workspace/BigdataEduDocs/2_Python_End2End/ref/file/bigSample.csv'\n",
    "\n",
    "%mprun -f genReadingCsv genReadingCsv(filename)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 디버깅"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def simulate(iterations, n=10000):\n",
    "    s = step(iterations, n)\n",
    "    x = np.cumsum(s, axis=0)\n",
    "    bins = np.arange(-30, 30, 1)\n",
    "    breakpoint() # 여기 주목!\n",
    "    y = np.vstack([np.histogram(x[i,:], bins)[0]\n",
    "                   for i in range(iterations)])\n",
    "    return y"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%debug simulate(50)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### zip, Itertools, list comprehension"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import itertools as it"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 1.zip : 지퍼를 채운다고 생각하면 기억하기 쉽다.\n",
    "zip([1, 2, 3], ['a', 'b', 'c'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 2.chain\n",
    "letters = ['a', 'b', 'c', 'd', 'e', 'f']\n",
    "booleans = [1, 0, 1, 0, 0, 1]\n",
    "decimals = [0.1, 0.7, 0.4, 0.4, 0.5]\n",
    "it.chain(letters, booleans, decimals)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 3.cycle\n",
    "for number, letter in zip(it.cycle(range(2)), ['a', 'b', 'c', 'd', 'e']):\n",
    "    print('{0}: {1}'.format(number, letter))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 4.repeat\n",
    "it.repeat('Hello, world!', 3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 5.count(시작, [step]) 의 함수로 시작 숫자부터 step만큼(없으면 1) 씩 무한히 증가하 제네레이터\n",
    "a = it.count(1,10)\n",
    "next(a)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 6. product\n",
    "it.product('ABCD', repeat=2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 7. permutation\n",
    "it.permutations('ABCD', 2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 8. combination\n",
    "it.combinations('ABCD', 2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 9. List comprehension\n",
    "[x**2 for x in range(0,50) if x % 3 == 0]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![listComprehension](./pics/list_comprehension.png)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#TODO powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\n",
    "#Hint : chain을 이용해 결과를 연결. chain.from_iterable 함수는 iterable을 인수로 받을 수 있음.\n",
    "def powerset(iterable):\n",
    "    None"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 실제 사용 예 : BOM - 불용 사양 제거(자료, 데이터 배포 X)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 오늘의 과제"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "우리가 가지고 있는 3GB 파일의 사전 정보가 아래와 같다고 하자\n",
    "\n",
    "1. 첫번째 컬럼 : ID\n",
    "2. 두번째 컬럼 : ID가 속한 상위 카테고리\n",
    "3. 세번째 컬럼 : 목표값\n",
    "4. 여섯 번째 컬럼~끝 : 각 ID가 시간 순서에 따라 가지는 값 \n",
    "\n",
    "1) 3GB 파일 전체를 category 와 id별로 평균과 분산 요약 테이블을 생성하라 (ID|Target|평균|분산|Category 의 컬럼 순서)\n",
    "\n",
    "2) 평균 and 분산 vs Target 의 3차원 Scatter Plot을 각 Category별로 분할된 하나의 Figure로 완성하라\n",
    "\n",
    "3) 파견 1일차에 학습한 Robust Scaling을 활용하여 2번을 동일하게 완성하라 \n",
    "\n",
    "4) 3을 기준으로 Regression을 수행하라.(Option, 예습)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 부록 -  과제와 무관합니다."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 3D Plot GIF Animation으로 만들기\n",
    "import pandas as pd, numpy as np, random\n",
    "import matplotlib.pyplot as plt, matplotlib.cm as cm\n",
    "from mpl_toolkits.mplot3d import Axes3D\n",
    "import IPython.display as IPdisplay\n",
    "import glob\n",
    "from PIL import Image as PIL_Image\n",
    "from images2gif import writeGif\n",
    " \n",
    "chaos_pops = logistic_model(generations=1000, growth_rate_min=3.99, growth_rate_max=4,\n",
    "                            growth_rate_steps=1)\n",
    "random_pops = pd.DataFrame([random.random() for _ in range(0,1000)], columns=['value'])\n",
    "pops = pd.concat([chaos_pops, random_pops], axis=1)\n",
    "pops.columns = ['chaos', 'random']\n",
    "pops.tail()\n",
    " \n",
    "gif_filename = '3d-phase-diagram-chaos-vs-random'\n",
    "fig, ax = get_pdiagram_3d(pops, color=['r', 'b'], xlabel='Population (t)',\n",
    "                          ylabel='Population (t + 1)', zlabel='',\n",
    "                          legend=True, legend_bbox_to_anchor=(0.94, 0.96))\n",
    " \n",
    "ax.elev = 89.9\n",
    "ax.azim = 270.1\n",
    "ax.dist = 11.0\n",
    " \n",
    "for n in range(0, 100):\n",
    "    if n >= 20 and n <= 22:\n",
    "        ax.set_xlabel('')\n",
    "        ax.set_ylabel('') #don't show axis labels while we move around, it looks weird\n",
    "        ax.elev = ax.elev-0.5 #start by panning down slowly\n",
    "    if n >= 23 and n <= 36: ax.elev = ax.elev-1.0 #pan down faster\n",
    "    if n >= 37 and n <= 60:\n",
    "        ax.elev = ax.elev-1.5\n",
    "        ax.azim = ax.azim+1.1 #pan down faster and start to rotate\n",
    "    if n >= 61 and n <= 64:\n",
    "        ax.elev = ax.elev-1.0\n",
    "        ax.azim = ax.azim+1.1 #pan down slower and rotate same speed\n",
    "    if n >= 65 and n <= 73:\n",
    "        ax.elev = ax.elev-0.5\n",
    "        ax.azim = ax.azim+1.1 #pan down slowly and rotate same speed\n",
    "    if n >= 74 and n <= 76:\n",
    "        ax.elev = ax.elev-0.2\n",
    "        ax.azim = ax.azim+0.5 #end by panning/rotating slowly to stopping position\n",
    "    if n = 77: #add axis labels at the end, when the plot isn't moving around\n",
    "        ax.set_xlabel('Population (t)')\n",
    "        ax.set_ylabel('Population (t + 1)')\n",
    "        ax.set_zlabel('Population (t + 2)')\n",
    "    fig.suptitle(u'3-D Poincaré Plot, chaos vs random', fontsize=12, x=0.5, y=0.85)\n",
    "    plt.savefig('images/' + gif_filename + '/img' + str(n).zfill(3) + '.png',\n",
    "                bbox_inches='tight')\n",
    " \n",
    " \n",
    "plt.close()\n",
    "images = [PIL_Image.open(image) for image in glob.glob('images/' + gif_filename + '/*.png')]\n",
    "file_path_name = 'images/' + gif_filename + '.gif'\n",
    "writeGif(file_path_name, images, duration=0.1)\n",
    "IPdisplay.Image(url=file_path_name)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
